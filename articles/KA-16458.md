---
title: "AEM analyse du vidage des threads"
description: Description
solution: Experience Manager
product: Experience Manager
applies-to: "Experience Manager"
keywords: "KCS"
resolution: Resolution
internal-notes: "Helpx Link: https://helpx.adobe.com/experience-manager/kb/thread-dump-analysis.html"
bug: false
article-created-by: Emily Geary
article-created-date: "3/17/2021 9:11:03 PM"
article-published-by: Emily Geary
article-published-date: "3/17/2021 9:13:37 PM"
version-number: 2
article-number: KA-16458
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=e70a8345-6587-eb11-a812-000d3a593216"
exl-id: 74bb70e4-a09b-48fc-8378-96a1736e5ebf
source-git-commit: a59847e2e7e37f432cb01150b9444cd9dbf585df
workflow-type: tm+mt
source-wordcount: '1000'
ht-degree: 1%

---

# AEM analyse des vidages de threads

## Description

Analyse des AEM [!DNL Java] vidages de threads à l’aide de [IBM Thread Analyzer](http://www.ibm.com/developerworks/community/groups/service/html/communityview?communityUuid=2245aa39-fa5c-4475-b891-14c205f7333c) outil.

## Résolution

1. Télécharger et installer [IBM Thread Analyzer](https://www.ibm.com/developerworks/community/groups/service/html/communityview?communityUuid=2245aa39-fa5c-4475-b891-14c205f7333c) (nous l’appellerons IBM TDA pour abréger)
1. Capture [images mémoire de threads](https://helpx.adobe.com/experience-manager/kb/TakeThreadDump.html) d’une instance d’AEM présentant des problèmes de performances.
1. Ouvrez les images mémoire de threads dans IBM TDA.
1. Pour afficher les détails d’un vidage de threads, sélectionnez le fichier dans la liste, puis cliquez sur le bouton &quot;Détails du thread&quot;\*.

![tda-threaddetail](https://helpx.adobe.com/content/dam/help/en/experience-manager/kb/thread-dump-analysis/_jcr_content/main-pars/image_1587732783/tda-threaddetail.png "tda-threaddetail")

1. Triez par &quot;Profondeur de pile&quot; avec les piles les plus longues au-dessus.

   ![tda-image1](https://helpx.adobe.com/content/dam/help/en/experience-manager/kb/thread-dump-analysis/_jcr_content/main-pars/image/tda-image1.png)

1. Examinez les threads avec une profondeur de pile de 10 lignes ou plus.  Ce sont généralement les fils d&#39;intérêt.  Prenez des notes sur les threads qui présentent un intérêt.
1. Tri par thread &quot;State&quot;
1. Faites défiler jusqu’aux threads &quot;Runnable&quot;. Les threads exécutables sont ceux qui prenaient activement du temps de processeur lorsque le thread dump a été exécuté.

   *Remarque : Lors de la révision des threads &quot;Runnable&quot;, vous pouvez ignorer les threads répertoriés dans la variable [Threads qui peuvent être ignorés](https://helpx.adobe.com/experience-manager/kb/thread-dump-analysis.html#ignorethreads) au bas de cette page.*

1. Recherchez les threads exécutables qui font partie de l’application, par exemple les threads de tâche en arrière-plan ou les threads de requête (les threads de requête portent des noms comme celui-ci). *127.0.0.1 1347028187737 /content/sites/global/en/sitemap.static-delivery.httpd.html HTTP/1.1*). Une fois que vous les avez trouvés, cliquez dessus un par un.

1. Pour chaque thread de requête, vous pouvez déterminer quand le navigateur de l’utilisateur a envoyé la requête au serveur en observant l’horodatage dans le nom du thread.  Par exemple, dans le nom du thread ci-dessus, l’horodatage (au format d’époque unix en millisecondes) est 1347028187737.  Nous pouvons convertir ce nombre d’époque en date/heure à l’aide de [www.epochconverter.com](http://www.epochconverter.com/).  Chaque thread dump affiche la date et l’heure de prise.  Vous pouvez prendre la différence de temps entre le temps de requête et le temps de vidage du thread pour voir pendant combien de temps une requête a été principale.

1. Après avoir examiné les threads de requête, faites défiler les autres threads &quot;Runnable&quot;.  Une fois que vous avez trouvé un fil &quot;Runnable&quot; intéressant, regardez le panneau du milieu, &quot;Waiting threads&quot; (En attente de threads).  Les threads répertoriés ici attendent que le thread sélectionné libère un moniteur.  Si vous ne voyez pas de threads en attente, le thread sélectionné peut toujours être propriétaire d’un [Verrouiller](http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/locks/Lock.html) (voir implémentation des classes de [Verrouiller](http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/locks/Lock.html) pour plus de détails). Par exemple, avec un [ReparticipantReadWriteLock](http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html) vous ne pouvez pas déterminer quel thread est l’espace de verrouillage, car les verrous implémentent plusieurs moniteurs en interne.  Vous devrez peut-être consulter le code source pour le faire correspondre à un thread qui pourrait être le cadenas.

1. Si le thread avait un verrou ou un moniteur que beaucoup d’autres threads attendaient alors passez par le reste des vidages de thread pour voir si vous pouvez trouver d’autres threads ayant le même problème.  Vérifiez si le même thread existe toujours dans les autres images mémoire (dans IBM TDA, vous pouvez sélectionner plusieurs images mémoire de threads et cliquer sur le bouton &quot;Comparer les threads&quot;\* pour afficher l’état d’un thread dans plusieurs images mémoire de threads.

   ![tda-compare-threads](https://helpx.adobe.com/content/dam/help/en/experience-manager/kb/thread-dump-analysis/_jcr_content/main-pars/image_1159496390/tda-comparethreads.png)

1. Reportez-vous au service Collector dans la capture d’écran ci-dessous :

   ![tda-Image2](https://helpx.adobe.com/content/dam/help/en/experience-manager/kb/thread-dump-analysis/_jcr_content/main-pars/image_1730877898/tda-Image2.png)

1. Dans cette vue, vous pouvez voir le thread dans plusieurs images mémoire de threads pour voir s’il s’agit d’un thread en cours d’exécution.  En gros, si le thread est à l’état Exécutable sur plusieurs vidages et a une longue pile, cela signifie généralement qu’il s’agit d’un thread à exécution longue.

1. Si vous n’avez pas vraiment consulté les threads exécutables, revenez à la liste des threads, sélectionnez un vidage de threads, puis cliquez sur le bouton &quot;Détails du moniteur&quot;\* dans le panneau supérieur. IBM TDA ouvre une fenêtre qui affiche une arborescence du moniteur propriétaire des threads et de leurs threads d’attente. Remarque : Il peut afficher certains threads du pool de threads comme le moniteur du pool de threads du moteur de servlet. Les threads inactifs peuvent être ignorés.  Vous pouvez généralement dire qu’un thread est un thread de pool de threads inactif car la plupart du temps, il n’a que 10 lignes de pile ou moins.

![tda-monitor-detail](https://helpx.adobe.com/content/dam/help/en/experience-manager/kb/thread-dump-analysis/_jcr_content/main-pars/image_1106466084/tda-monitordetail.png)

<b>Utilisation du processeur au niveau du thread ([!DNL Linux] platform uniquement) :</b>

1. Si vous avez capturé la sortie &quot;top -H -b -n1 -p javapid&quot; en plus des images mémoire de threads, vous pouvez effectuer une référence croisée à l’utilisation du processeur au niveau du thread.  Ouvrez la sortie supérieure et obtenez l’ID de processus des threads qui utilisent le processeur.  Convertissez l’ID de processus en hexadécimal, puis recherchez cette valeur hexadécimale dans le fichier de vidage de thread correspondant.  L’identifiant doit correspondre à l’identifiant &quot;nid&quot; de l’un des threads.
1. Si le thread correspondant utilisant le plus de processeur est le &quot;thread VM&quot; ou tout autre thread &quot;GC&quot;, il se peut que vous rencontriez un problème de mémoire.  Répétez le même exercice pour plus d’images mémoire de threads et une sortie supérieure. Si ces threads prennent du temps au processeur, un problème de mémoire se produit.
1. Si vous avez confirmé le problème de mémoire, capturez un vidage de tas la prochaine fois que le problème se produira.  Voir [cet article](https://helpx.adobe.com/fr/experience-manager/kb/AnalyzeMemoryProblems.html) pour plus d’informations sur la capture et l’analyse des vidages de tas.

![](https://helpx.adobe.com/libs/cq/ui/resources/0.gif)![](https://helpx.adobe.com/libs/cq/ui/resources/0.gif)

Threads qui peuvent être ignorés :

- Thread VM : C&#39;est un thread du système VM.
- Threads commençant par le thread de tâche GC : Ce sont des fils de nettoyage de la mémoire.
- Threads avec des noms similaires à - 1347028691218 dans le code à l’adresse java.net.PlainSocketImpl.socketAccept(Méthode native) : Il s’agit de threads provenant du pool de threads du moteur de servlet en attente de nouvelles connexions.
