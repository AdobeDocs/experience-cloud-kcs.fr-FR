---
title: 'Campaign Classic : la requête incrémentielle récupère tous les enregistrements au lieu de seulement les nouveaux.'
description: Description
solution: Campaign
product: Campaign
applies-to: Campaign Classic
keywords: KCS
resolution: Resolution
internal-notes: Ticket = TK197178
bug: true
article-created-by: Marta Zator
article-created-date: 5/10/2022 9:47:14 AM
article-published-by: Marta Zator
article-published-date: 5/10/2022 9:51:21 AM
version-number: 2
article-number: KA-15190
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=ad8bd527-46d0-ec11-a7b5-00224809c101
exl-id: f3dee0a7-8047-4949-9162-de95ba07fa7f
source-git-commit: e8f4ca2dd578944d4fe399074fab461de88ad247
workflow-type: tm+mt
source-wordcount: '508'
ht-degree: 0%

---

# Campaign Classic : la requête incrémentielle récupère tous les enregistrements au lieu de seulement les nouveaux.

## Description


Le client possède plusieurs requêtes incrémentielles qui ne fonctionnent pas comme prévu. Au lieu de ne sélectionner que de nouveaux enregistrements depuis leur dernière exécution, ils récupèrent tous les enregistrements à chaque fois, comme une activité de requête normale.


## Résolution


Le coupable est le workflow de nettoyage.

Le workflow de requête incrémentale fonctionne de la manière suivante :

0. Conserver une table d&#39;historique avec les résultats des itérations précédentes.
1. Récupérez TOUTES les lignes de la requête cible.
2. Filtrage de toutes les lignes présentes dans le tableau d’historique
3. Ajoutez les résultats restants dans le tableau history pour le filtrage de l&#39;itération suivante.

Ainsi, ce nom de table de travail de l’historique est de la notation suivante :
*wkfhistoworkflowid* activityName_

Désormais, pour les ID de workflow 0 (pour les clients où la variable `xtknewid` autorise des séquences négatives), nous voyons qu’il s’agit en fait de :

*wkfhisto(uint)workflows* activityName_

Bien que cela soit correct pour l’exécution des workflows.

Par exemple, l’activité incrémentale `incremental1` de workflow ID=-1 crée un tableau `wkfhisto4294967295_incremental1`.

La chose qui manque est le workflow Nettoyage.

Ici, nous avons un code qui tente de supprimer des tables de travail des workflows supprimés.

Ici, un code dédié répertorie toutes les tables wkfhisto\*, extrait le workflowId de leurs noms (à partir de la convention ci-dessus) et les supprime, à l’exception de celles dont les worklowID se trouvent dans la table xtkworkflow.

Cependant, il manque la variable `uint` partie

Il tente donc de rechercher un workflow avec l’ID 4294967295 au lieu de retransmettre cette information à l’entier. Ce workflow étant introuvable, cette table est supprimée. La prochaine fois, lorsque ce workflow s&#39;exécute, l&#39;activité de requête incrémentale ne trouve pas de table d&#39;historique existante et la crée en la considérant comme la première exécution.

<b>Correction:</b>

Le correctif pour ce problème est disponible dans la version Adobe Campaign Classic 20.1.1 (version 9122 et ultérieure).

<b>Solutions que les clients peuvent utiliser :</b>

Solution 1 : Arrêtez le workflow de nettoyage et exécutez-le par intermittence pour nettoyer la base de données et le disque dur jusqu’à ce que le correctif soit pris et disponible. Non recommandé si vous n’avez pas prévu de mise à niveau.

Solution 2 : Supposons que l’activité Requête incrémentale soit affectée et contournée en faisant la même chose que la Requête incrémentale en créant un schéma persistant destiné à contenir le contenu de la table d’historique. Utilisez une combinaison d’activités de requête et de mise à jour de données pour imiter le comportement. Cela doit être effectué pour tous les workflows nécessitant la requête incrémentale.

Solution 3 :  Supposons que l’activité Requête incrémentale soit affectée et contourne le problème en ajoutant un champ d’audit (tsCreated/tsLastModified) au schéma en question. Votre requête incrémentale sera alors convertie en activité de requête normale avec une clause où comme `tscreated GetDate()`.

Solution 4 :

- Créez une nouvelle séquence xtknewworkflows et initialisez-la à un élément éloigné des plages d’ID de workflow actuelles.
- Modifier le schéma xtkworkflow pour utiliser cette pkSequence
- Demandez au client de cloner tous les workflows concernés et de supprimer les workflows d&#39;origine.
- Une fois que le client est prêt pour une mise à niveau, supprimez ce correctif en revenant à xtknownId pour la création du workflow (afin d’éviter des surprises indésirables).
