---
title: « L’exception SegmentNotFoundException des journaux et de l’instance AEM ne fonctionne pas »
description: « Découvrez comment résoudre le problème SegmentNotFoundException dans les journaux et l’instance AEM. »
solution: Experience Manager
product: Experience Manager
applies-to: "Experience Manager 6.4,Experience Manager"
keywords: « KCS, SegmentNotFoundException, journal AEM, AEM 6.x, »
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Jim Menn
article-created-date: "4/9/2024 1:16:49 PM"
article-published-by: Jim Menn
article-published-date: "4/9/2024 1:23:15 PM"
version-number: 6
article-number: KA-23644
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=3db0de66-73f6-ee11-a1fe-6045bd006268"
source-git-commit: 4ffbe1419cd9f1aadd1c6ad6ce87f0c6f1762ec1
workflow-type: tm+mt
source-wordcount: '855'
ht-degree: 8%

---

# L’exception SegmentNotFoundException des journaux et de l’instance AEM ne fonctionne pas


Découvrez comment résoudre le problème SegmentNotFoundException dans les journaux et instances AEM en procédant comme suit.

*Remarque : effectuez une sauvegarde complète du référentiel avant de suivre les étapes.*

## Description {#description}


### <b>Environnement</b>

Adobe Experience Manager 6.x (AEM 6.x)

### <b>Problème/Symptômes</b>

`SegmentNotFoundException` dans les fichiers journaux AEM et AEM ne fonctionne pas comme prévu.

L’exécution d’un compactage hors ligne peut échouer avec l’exception SegmentNotFoundException en cas de problèmes d’intégrité dans le référentiel. A <b>Trace de la pile </b>similaire à celui ci-dessous se trouve dans les journaux :

`13:51:21.523 [ main]  ERROR o.a.j.o.p.segment.SegmentTracker - Segment not found: 4d139bc4-150c-4f0a-b82a-40a4e519fe8a. Creation date delta is 4 ms. org.apache.jackrabbit.oak.plugins.segment.SegmentNotFoundException: Segment 4d139bc4-150c-4f0a-b82a-40a4e519fe8a not found at org.apache.jackrabbit.oak.plugins.segment.file.FileStore.readSegment(FileStore.java:855) [ oak-run-1.0.22.jar:1.0.22]  at org.apache.jackrabbit.oak.plugins.segment.SegmentTracker.getSegment(SegmentTracker.java:134) ~[ oak-run-1.0.22.jar:1.0.22]  at org.apache.jackrabbit.oak.plugins.segment.SegmentId.getSegment(SegmentId.java:101) [ oak-run-1.0.22.jar:1.0.22]  ... Exception in thread "main" org.apache.jackrabbit.oak.plugins.segment.SegmentNotFoundException: Segment 4d139bc4-150c-4f0a-b82a-40a4e519fe8a not found at org.apache.jackrabbit.oak.plugins.segment.file.FileStore.readSegment(FileStore.java:855) at org.apache.jackrabbit.oak.plugins.segment.SegmentTracker.getSegment(SegmentTracker.java:134) at org.apache.jackrabbit.oak.plugins.segment.SegmentId.getSegment(SegmentId.java:101) ...`

L’exécution d’une compression hors ligne peut échouer avec `IllegalArgument` exception en cas de problèmes d’intégrité dans le référentiel. A <b>Trace de la pile</b> similaire à celui ci-dessous se trouve dans les journaux :



`java.lang.IllegalArgumentException at com.google.common.base.Preconditions.checkArgument(Preconditions.java:77) at org.apache.jackrabbit.oak.plugins.segment.ListRecord.(ListRecord.java:41) at org.apache.jackrabbit.oak.plugins.segment.ListRecord.getEntry(ListRecord.java:64) at org.apache.jackrabbit.oak.plugins.segment.ListRecord.getEntries(ListRecord.java:81) at org.apache.jackrabbit.oak.plugins.segment.SegmentStream.read(SegmentStream.java:153) at org.apache.jackrabbit.oak.commons.IOUtils.readFully(IOUtils.java:53) at org.apache.jackrabbit.oak.plugins.segment.Compactor.getBlobKey(Compactor.java:412) at org.apache.jackrabbit.oak.plugins.segment.Compactor.compact(Compactor.java:362) at org.apache.jackrabbit.oak.plugins.segment.Compactor.compact(Compactor.java:321) at org.apache.jackrabbit.oak.plugins.segment.Compactor.access$500(Compactor.java:54) at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.propertyAdded(Compactor.java:227) at org.apache.jackrabbit.oak.plugins.segment.CancelableDiff.propertyAdded(CancelableDiff.java:47) at org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.compareAgainstEmptyState(EmptyNodeState.java:156) at org.apache.jackrabbit.oak.plugins.segment.SegmentNodeState.compareAgainstBaseState(SegmentNodeState.java:434) at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.diff(Compactor.java:214) at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.childNodeAdded(Compactor.java:263) at org.apache.jackrabbit.oak.plugins.segment.CancelableDiff.childNodeAdded(CancelableDiff.java:74) at org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.compareAgainstEmptyState(EmptyNodeState.java:161) at org.apache.jackrabbit.oak.plugins.segment.SegmentNodeState.compareAgainstBaseState(SegmentNodeState.java:434) at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.diff(Compactor.java:214) at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.childNodeAdded(Compactor.java:263) at org.apache.jackrabbit.oak.plugins.segment.CancelableDiff.childNodeAdded(CancelableDiff.java:74) at org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.compareAgainstEmptyState(EmptyNodeState.java:161) at org.apache.jackrabbit.oak.plugins.segment.SegmentNodeState.compareAgainstBaseState(SegmentNodeState.java:434) at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.diff(Compactor.java:214) at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.childNodeAdded(Compactor.java:263) at org.apache.jackrabbit.oak.plugins.segment.CancelableDiff.childNodeAdded(CancelableDiff.java:74) at org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.compareAgainstEmptyState(EmptyNodeState.java:161) at org.apache.jackrabbit.oak.plugins.segment.SegmentNodeState.compareAgainstBaseState(SegmentNodeState.java:434) at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.diff(Compactor.java:214) at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.childNodeAdded(Compactor.java:263) at org.apache.jackrabbit.oak.plugins.segment.CancelableDiff.childNodeAdded(CancelableDiff.java:74)`


## Résolution {#resolution}


<b>Première méthode :</b>

- Télécharger le <b>oak-run</b> fichier jar disponible ici [https://repo1.maven.org/maven2/org/apache/jackrabbit/oak-run/](http://repo1.maven.org/maven2/org/apache/jackrabbit/oak-run/).
- Arrêtez l’AEM. (Adobe Experience Manager)
- Exécutez la commande suivante : `java -jar oak-run-*.jar check --bin=-1 crx-quickstart/repository/segmentstore/`    Cette commande effectue une recherche vers le haut dans les révisions jusqu’à ce qu’elle en trouve une cohérente :
  `14:00:30.783 [ main]  INFO o.a.j.o.p.s.f.t.ConsistencyChecker - Found latest good revision afdb922d-ba53-4a1b-aa1b-1cb044b535cf:234880`
(En cas d’échec de ConsistencyChecker, accédez à la section suivante)
- Rétablissez le référentiel de cette révision en modifiant la commande donnée ci-dessous.    `/crx-quickstart/repository/segmentstore/journal.log.`
Supprimez toutes les lignes après la ligne contenant la dernière bonne révision. Pour déterminer la date et l’heure à rétablir dans le référentiel, exécutez cette commande dans le dossier segmentstore (remplacez afdb922d-ba53-4a1b-aa1b-1cb044b535cf par la dernière bonne révision du journal.log) :
  `find . -type f -name "data*.tar" -exec sh -c "tar -tvf {} |grep afdb922d-ba53-4a1b-aa1b-1cb044b535cf" \; -print`
La sortie affiche une date et une heure approximatives de cette révision.
- Tout supprimer `./crx-quickstart/repository/segmentstore/*.bak files`.
- Si AEM6.0 est utilisé, téléchargez la version oak-run correspondant à la version installée dans AEM pour les étapes restantes. Téléchargez-le à partir de ce lien : [https://repo1.maven.org/maven2/org/apache/jackrabbit/oak-run/.](http://repo1.maven.org/maven2/org/apache/jackrabbit/oak-run/.)
- Exécutez le nettoyage des points de contrôle pour supprimer les points de contrôle orphelins :    `java -jar oak-run-*.jar checkpoints ./crx-quickstart/repository/segmentstore rm-unreferenced.`
- Enfin, compactez le référentiel :    `java -jar oak-run-*.jar compact ./crx-quickstart/repository/segmentstore/`.




<b>Deuxième méthode alternative :</b>

Supprimez manuellement les nœuds corrompus.

Dans AEM, les configurations TarMK sans FileDatastore configuré et les situations où la corruption se trouve dans les binaires, procédez comme suit :

Attention :

La procédure ci-dessous est destinée aux utilisateurs expérimentés.  Lors de la suppression des nœuds corrompus, vous devez vous assurer qu’il ne s’agit pas de nœuds système (tels que /home, /jcr:system, etc.) .  Ou s’il s’agit de nœuds système, vous devez vous assurer que vous pouvez les restaurer.  Si vous n’êtes pas sûr, veuillez consulter l’équipe d’assistance clientèle AEM pour obtenir de l’aide sur les étapes décrites ici.


 
- Arrêtez l’AEM. (Adobe Experience Manager)
- Utiliser la console Oak-run et charger le<b> childCount </b>script groovy pour identifier les nœuds corrompus dans l’entrepôt de segments : chargez le shell de la console oak-run :
  `java -jar oak-run-*.jar console crx-quickstart/repository/segmentstore`
Exécutez les deux commandes ci-dessous dans le shell pour charger le script et l’exécuter : `:` `load https://gist.githubusercontent.com/stillalex/e7067bcb86c89bef66c8/raw/d7a5a9b839c3bb0ae5840252022f871fd38374d3/childCount.groovy countNodes(session.workingNode)`
Cela entraîne la sortie suivante indiquant le chemin d’accès aux nœuds corrompus :
  `21:21:42.029 [ main]  ERROR o.a.j.o.p.segment.SegmentTracker - Segment not found: 63ae05a4-b506-445c-baa2-cfa1b13b6e2f. Creation date delta is 3 ms. warning unable to read node /content/dam/test.txt/jcr:content/renditions/original/jcr:content`
Dans certains cas, le problème est lié à des propriétés binaires et le script groovy childCount ne parvient pas à localiser les nœuds corrompus. Dans ces cas, vous pouvez utiliser la commande suivante à la place, qui lira les 1 024 premiers octets pour chaque fichier binaire rencontré lors du parcours. (Notez que cette commande sera plus lente et ne doit être utilisée que lorsque la solution ci-dessus ne renvoie pas les résultats attendus) :
  `countNodes(session.workingNode,true)`
- Supprimez tous les nœuds corrompus identifiés répertoriés dans la sortie de la dernière commande à l’aide de rmNodes.groovy Chargez le shell de la console oak-run :
  `java -jar oak-run-*.jar console crx-quickstart/repository/segmentstore`
Chargez le script groovy :
  `:load https://gist.githubusercontent.com/stillalex/43c49af065e3dd1fd5bf/raw/9e726a59f75b46e7b474f7ac763b0888d5a3f0c3/rmNode.groovy`
Exécutez la commande rmNode pour supprimer le nœud corrompu, remplacez <b>/path/to/corrupt/node </b>avec le chemin d’accès au nœud corrompu, vous devez supprimer.
  `rmNode(session, "/path/to/corrupt/node")`
Où le chemin de nœud corrompu est le chemin obtenu à l’étape 2, par exemple : `"/content/dam/test.txt/jcr:content/renditions/original/jcr:content/"`
  <b>Remarque :</b>
  <b>Lors de l’utilisation de oak-run.jar version 1.6.13 et ultérieure, définissez le paramètre JVM lecture-écriture si vous rencontrez une erreur telle que :</b>
  `/> rmNode(session,"/path/to/corrupt/node") Removing node /path/to/corrupt/node ERROR java.lang.UnsupportedOperationException: Cannot write to read-only store at org.apache.jackrabbit.oak.segment.SegmentWriterBuilder$1.execute (SegmentWriterBuilder.java:171) at org.apache.jackrabbit.oak.segment.SegmentWriter.writeNode (SegmentWriter.java:318) at org.apache.jackrabbit.oak.segment.SegmentNodeBuilder.getNodeState (SegmentNodeBuilder.java:111) at org.apache.jackrabbit.oak.segment.SegmentNodeStore$Commit. (SegmentNodeStore.java:581) at org.apache.jackrabbit.oak.segment.SegmentNodeStore.merge (SegmentNodeStore.java:333) at org.apache.jackrabbit.oak.spi.state.NodeStore$merge.call (Unknown Source) at groovysh_evaluate.rmNode (groovysh_evaluate:11)`
- Répétez l’étape 3 pour tous les nœuds trouvés à l’étape 2.    <b>La commande rmNode ci-dessus doit renvoyer la valeur true pour le chemin d’accès corrompu, ce qui signifie qu’elle l’a supprimé. Vérifiez que ces trois chemins d’accès corrompus sont supprimés en réexécutant la commande rmNode sur ces chemins d’accès. La prochaine exécution doit renvoyer la valeur false.</b>
  *Si le référentiel contient les mêmes chemins, il est conseillé d’utiliser la version corrigée du fichier oak-run jar, c’est-à-dire oak-run-1.2.18-NPR-17596*
  <b>À quoi sert la version corrigée du fichier Oak-run jar ?</b>
Cette version de jar ignore les binaires illisibles lors du compactage, les remplaçant par des binaires de 0 octet et consignant l’exception et le chemin d’accès dans syserr (*Fenêtre Messages d’erreur*). Le référentiel compacté doit alors transmettre la vérification oak-run, le script du nombre de nœuds et doit également pouvoir être compacté à nouveau à l’aide d’un oak-run non corrigé.
- Effectuez un nettoyage de point de contrôle en répertoriant les points de contrôle à l’aide de la commande ci-dessous. S’il existe plusieurs points de contrôle, nettoyez-les :    `nohup java -Xmx4096m -jar oak-run-1.2.18.jar checkpoints /app/AEM6/author/crx-quickstart/repository/segmentstore rm-all>>nohup.out &`
- Exécutez un compactage hors ligne. Découvrez comment[exécuter le compactage hors ligne](https://gist.github.com/andrewmkhoury/0b1fe4d8b619178ff87b) ici.
- Démarrez le serveur et attendez la fin de l’indexation.



<br>Cause <br>
A `SegmentNotFoundException` est renvoyée lorsqu’un segment n’est pas présent alors que la compression tente de lire le nœud. Les causes peuvent être différentes :

1. Le segment a été supprimé par une intervention manuelle (par exemple, rm -rf /).
2. Le segment a été supprimé par la récupération de l’espace mémoire de révision.
3. Le segment est introuvable en raison d’un bogue dans le code .


Si le problème est dû au nettoyage de la mémoire de révision (point 2), assurez-vous que le compactage en ligne est désactivé pour éviter que d’autres nœuds ne soient corrompus.
