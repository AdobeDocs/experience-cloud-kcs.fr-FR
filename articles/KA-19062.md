---
title: Comment déboguer SegmentNotFoundException lorsque le problème est signalé dans AEM 6.x
description: Description
solution: Experience Manager
product: Experience Manager
applies-to: Experience Manager
keywords: KCS
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Akash Kapoor
article-created-date: 4/3/2022 7:14:43 PM
article-published-by: Akash Kapoor
article-published-date: 4/3/2022 7:14:58 PM
version-number: 4
article-number: KA-19062
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=63dd174c-82b3-ec11-983f-000d3a5d09d6
exl-id: 0580f08b-a72c-45ec-817e-e850d2360e9d
source-git-commit: e8f4ca2dd578944d4fe399074fab461de88ad247
workflow-type: tm+mt
source-wordcount: '1214'
ht-degree: 0%

---

# Comment déboguer SegmentNotFoundException lorsque le problème est signalé dans AEM 6.x

## Description


<b>Comment déboguer SegmentNotFoundException lorsque le problème est signalé dans AEM 6.x</b>

A <b>SegmentNotFoundException</b> dans le journal des erreurs signifie qu’un segment n’est plus présent, bien qu’une personne essaie apparemment de l’y accéder. Il existe en gros trois causes principales : le segment a été supprimé par une intervention manuelle (par exemple rm -rf /), le segment a été supprimé par le nettoyage de la mémoire de révision ou le segment est introuvable en raison d’un bogue dans le code.

Il peut y avoir une exception, comme ce qui suit peut être affiché dans les journaux :

...

org.apache.jackrabbit.oak.segment.SegmentNotFoundException : Segment d2c720c4-c146-4ab1-ac37-542aad93c33f introuvable à org.apache.jackrabbit.oak.segment.file.FileStore$8.call(FileStore.java:602) à org.apache.jackrabbit.jackrabbit.jackpot ak.segment.file.FileStore$8.call(FileStore.java:542) à org.apache.jackrabbit.oak.segment.SegmentCache.getSegment(SegmentCache.java:95) à org.apache.jackrabbit.oak.segment.file.FileStore.readSegment(FileStore.java:54) 2) à org.apache.jackrabbit.oak.segment.SegmentId.getSegment(SegmentId.java:125) à org.apache.jackrabbit.oak.segment.Record.getSegment(Record.java:70) à org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java) : 424) à l’adresse org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:433) à l’adresse org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:391) à l’adresse org.apache.jackrabbit.oak.segment.SegmentNodeNodeComparaison.ComparaisonEtatComparerComparaisonComparaison AgainstBaseState(SegmentNodeState.java:608) à org.apache.jackrabbit.oak.spi.commit.EditorDiff.childNodeChanged(EditorDiff.java:148) à org.apache.jackrabbit.oak.segment.MapRecord$3.childNodeChanged(RecordMap java:442) à org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:490) à org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:433) à org.apache.jackrabbit.oak.segment.SegmentNodeState .compareAgainstBaseState(SegmentNodeState.java:608) à org.apache.jackrabbit.oak.spi.commit.EditorDiff.process(EditorDiff.java:52) à org.apache.jackrabbit.oak.plugins.index.AsyncIndexUpdate.updateIndex(AsyncIndexUpdate) java:695) à org.apache.jackrabbit.oak.plugins.index.AsyncIndexUpdate.runWhenPermitted(AsyncIndexUpdate.java:543) à org.apache.jackrabbit.oak.plugins.index.AsyncIndexUpdate.run(AsyncIndexUpdate.java:40) 2) à org.apache.sling.commons.scheduler.impl.QuartzJobExecutor.execute(QuartzJobExecutor.java:118) à org.quartz.core.JobRunShell.run(JobRunShell.java:202) à java.util.concurrent.ThreadPoolExecutor.runWorker(read) PoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at java.lang.Thread.run(Thread.java:745)

...


## Résolution


Nous pouvons suivre deux approches pour résoudre le problème et supprimer les incohérences dans le référentiel décrites ci-dessous dans les sections A et B.

<b>A. Revenez à la dernière révision correcte connue du magasin de segments.</b>

Tout d’abord, nous devrions utiliser l’outil d’exécution Oak, un jar1 exécutable qui contient tout ce dont vous avez besoin pour une installation Oak simple et effectuer des opérations liées à Oak.

Le mode d’exécution de vérification de oak-run peut être utilisé pour déterminer la dernière bonne révision connue d’un magasin de segments.  Cela peut être utilisé pour rétablir manuellement un magasin de segments corrompu à sa dernière bonne révision.

*Attention : Ce processus restaurera les données du système à un point antérieur dans le temps.  Si vous souhaitez éviter de perdre des modifications dans votre système, vous pouvez plutôt essayer l’option B ci-dessous.*

Pour effectuer la vérification et la restauration :

1. Téléchargez une version de oak-run correspondant à votre version principale oak à partir de [https://mvnrepository.com/artifact/org.apache.jackrabbit/oak-run](https://mvnrepository.com/artifact/org.apache.jackrabbit/oak-run)
2. Pour rétablir un magasin de segments corrompu à son dernier bon état de transformation dans le répertoire de travail de CQ (celui contenant le dossier crx-quickstart) et sauvegarder tous les fichiers dans ./crx-quickstart/repository/segmentstore/.
3. Exécutez la vérification de cohérence java -Xmx6000m -jar oak-run-\*.jar check —bin=-1 /path/to/crx-quickstart/repository/segmentstore Cette recherche en amont dans les révisions jusqu’à ce qu’elle trouve une vérification cohérente : Recherchez le message suivant : main INFO o.a.j.o.p.s.f.t.ConsistencyChecker - Dernière bonne révision afdb922d-ba53-4a1b-aa1b-1cb044b535cf:234880
4. Rétablissez le référentiel à cette révision en modifiant ./crx-quickstart/repository/segmentstore/journal.log et supprimer toutes les lignes après la ligne contenant la dernière bonne révision.
5. Tout supprimer ./crx-quickstart/repository/segmentstore/\*.bak .
6. Exécutez le nettoyage des points de contrôle pour supprimer les points de contrôle orphelins à l’aide de la commande suivante : java -Xmx6000m -jar oak-run-\*.jar points de contrôle /path/to/crx-quickstart/repository/segmentstore rm-unreferenced
7. Enfin, compactez le référentiel : java -Xmx6000m -jar oak-run-\*.jar compact /path/to/crx-quickstart/repository/segmentstore/




*Il peut arriver que la vérification d’exécution oak ne trouve pas la bonne révision et que &quot;ConsistencyChecker - No good revision found&quot; soit obtenu lors de l’exécution de la commande de vérification.*
<b>Comment corriger la corruption lors de la rencontre de &quot;ConsistencyChecker - Aucune bonne révision trouvée&quot; lors de la vérification de cohérence</b>


<b>B. Supprimez manuellement les noeuds corrompus.</b>

Dans AEM, les configurations TarMK sans FileDatastore configurées et les situations où la corruption se trouve dans les binaires, vous pouvez effectuer les opérations suivantes.

\*Attentionn:\*La procédure ci-dessous est destinée aux utilisateurs expérimentés.  Lors de la suppression des noeuds corrompus, vous devez vous assurer qu’ils ne sont pas des noeuds système (comme /home, /jcr:system, etc.).  Ou s’il s’agit de noeuds système, vous devez vous assurer que vous pouvez les restaurer.  Si vous n’êtes pas sûr, veuillez consulter AEM équipe d’assistance clientèle pour obtenir de l’aide sur les étapes décrites ici.



1. Arrêtez d&#39;AEM.
2. Utilisez la console d’exécution Oak et chargez le script enfantCount groovy pour identifier les noeuds corrompus dans le magasin de segments :


Chargez le shell de la console oak-run :

java -jar oak-run-\*.jar console crx-quickstart/repository/segmentstore

Exécutez les deux commandes ci-dessous dans le shell pour charger le script et l’exécuter :

:load https://gist.githubusercontent.com/stillalex/e7067bcb86c89bef66c8/raw/d7a5a9b839c3bb0ae5840252022f871fd38374d3/childCount.groovy

countNodes(session.workingNode)

Cela entraîne la sortie suivante indiquant le chemin d’accès au ou aux noeuds corrompus :

21:21:42.029 ERREUR principale o.a.j.o.p.segment.SegmentTracker - Segment introuvable : 63ae05a4-b506-445c-baa2-cfa1b13b6e2f. Le delta de date de création est de 3 ms.

avertissement impossible de lire le noeud /content/dam/test.txt/jcr:content/renditions/original/jcr:content

Dans certains cas, le problème est lié à des propriétés binaires et le script groovy childCount ne parvient pas à localiser les noeuds corrompus.  Dans ce cas, vous pouvez utiliser plutôt la commande suivante qui lira les 1 024 premiers octets pour chaque binaire rencontré lors de la traversée (Notez que cette commande sera plus lente et ne doit être utilisée que lorsque celle ci-dessus ne renvoie pas les résultats attendus) :

countNodes(session.workingNode,true)

3. Supprimez tous les noeuds corrompus identifiés répertoriés dans la sortie de la dernière commande à l’aide de rmNodes.groovy.

Chargez le shell de la console oak-run à l’aide de la commande suivante :

java -jar oak-run-\*.jar console crx-quickstart/repository/segmentstore

Chargez le script groovy :

:load

https://gist.githubusercontent.com/stillalex/43c49af065e3dd1fd5bf/raw/9e726a59f75b46e7b474f7ac763b0888d5a3f0c3/rmNode.groovy

Exécutez la commande rmNode pour supprimer le noeud corrompu, remplacez /path/to/corruption/node par le chemin d’accès au noeud corrompu que vous devez supprimer.

rmNode(session, &quot;/path/to/corruption/node&quot;)

Où le chemin du noeud corrompu est le chemin obtenu à l’étape 2, par exemple : &quot;/content/dam/test.txt/jcr:content/renditions/original/jcr:content/&quot; Remarque : Lors de l’utilisation de oak-run.jar version 1.6.13 et ultérieure, définissez le paramètre JVM —read-write si vous rencontrez une erreur telle que :

/ rmNode(session,&quot;/path/to/corruption/node&quot;) Suppression du noeud /path/to/corruption/node ERROR java.lang.UnsupportedOperationException :    Impossible d’écrire en lecture seule dans le magasin org.apache.jackrabbit.oak.segment.SegmentWriterBuilder$1.execute (SegmentWriterBuilder.java:171) à org.apache.jackrabbit.oak.segment.SegmentWriter.writeNode (SegmentWriter.java:318) à org.apache. jackrabbit.oak.segment.SegmentNodeBuilder.getNodeState (SegmentNodeBuilder.java:111) à org.apache.jackrabbit.oak.segment.SegmentNodeStore$Commit.init (SegmentNodeStore.java:581) à org.apache.jackrabbit.jackrabbit.ak.segment.SegmentNodeStore.merge (SegmentNodeStore.java:333) à org.apache.jackrabbit.oak.spi.state.NodeStore$merge.call (Source inconnue) à groovysh_evaluate.rmNode (groovysh_evaluate:11)

4. Répétez l’étape 3 pour tous les noeuds trouvés à l’étape 2.

La commande rmNode ci-dessus doit renvoyer la valeur true pour le chemin corrompu, ce qui signifie qu’elle l’a supprimé. Assurez-vous que ces trois chemins corrompus sont supprimés en exécutant à nouveau la commande rmNode sur ces chemins. La prochaine exécution doit renvoyer la valeur false.

Si vous constatez toujours que les mêmes chemins d’accès se trouvent dans le référentiel, utilisez la version corrigée de oak-run jar, c’est-à-dire oak-run-1.2.18-NPR-17596.

Qu’est-ce que la version corrigée de Oak exécute Jar Do ?

Cette version de jar ignore les fichiers binaires illisibles lors de la compression et les remplace par des fichiers binaires de 0 octet ; elle consigne l’exception et le chemin d’accès au système. Le référentiel ainsi compacté doit alors transmettre la vérification oak-run, le script node count et vous devriez également être en mesure de le compacter à nouveau à l’aide d’une exécution oak non corrigée.

5. Effectuez un nettoyage de point de contrôle en répertoriant les points de contrôle à l’aide de ci-dessous. S’il existe plusieurs points de contrôle, nettoyez-les :

nohup java -Xmx4096m -jar oak-run-1.2.18.jar points de contrôle /app/AEM6/author/crx-quickstart/repository/segmentstore rm-allnohup.out &amp;

6. Exécutez une compression hors ligne.  Si vous ne savez pas exécuter le compactage hors ligne, reportez-vous à la section [here](https://gist.github.com/andrewmkhoury/0b1fe4d8b619178ff87b).

7. Démarrez le serveur pour que l’indexation soit terminée.
