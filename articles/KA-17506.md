---
title: Analyse du protocole SMPP à l’aide de Wireshark
description: Description
solution: Campaign
product: Campaign
applies-to: Campaign Classic
keywords: KCS, SMPP, Wireshark
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Craig Thonis
article-created-date: 5/6/2022 3:51:03 PM
article-published-by: Craig Thonis
article-published-date: 5/6/2022 3:52:19 PM
version-number: 4
article-number: KA-17506
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=9319e64e-54cd-ec11-a7b5-6045bd00d4f5
exl-id: 39c89da2-36ae-4c66-9553-cfc3d5b4003a
source-git-commit: e8f4ca2dd578944d4fe399074fab461de88ad247
workflow-type: tm+mt
source-wordcount: '2545'
ht-degree: 4%

---

# Analyse du protocole SMPP à l’aide de Wireshark

## Description

<br>Découvrez comment analyser le trafic SMPP à l’aide de Wireshark.<br><br><br><br><br>Introduction<br><br><br><br> <br><br>
La plupart des SMS-C à haut débit sont compatibles avec la version 3.4 du protocole SMPP. Ce protocole permet d&#39;envoyer des SMS et de recevoir des informations sur la diffusion de ces SMS. Le protocole SMPP est documenté dans la spécification du protocole SMPP v3.4 disponible sur Internet en tant que document de PDF.

Cet article ne remplace pas cette spécification : il fournit des conseils pratiques sur la manière d’interpréter la spécification du protocole et de la faire correspondre à l’affichage Wireshark afin de résoudre les problèmes entre Adobe Campaign et le partenaire SMS-C.

Comme le protocole SMPP contient de nombreuses parties différentes laissées à l&#39;interprétation de l&#39;équipe de mise en oeuvre, il existe des différences entre les différents SMS-C.

Lorsque vous résolvez les problèmes, contactez toujours le partenaire SMS-C pour obtenir des informations ou pour vous aider à vérifier ce que vous obtenez. Si le SMS-C répond en erreur, votre partenaire SMS-C sera la meilleure personne pour vous dire pourquoi il a répondu avec l&#39;erreur. Si vous utilisez un simulateur SMPP au lieu de vous connecter à un véritable SMS-C, vous devez utiliser le code source (ou un débogueur) pour comprendre ce qui se passe.


## Résolution

<br><br>Capture du trafic réseau sans Wireshark<br><br><br><br><br><br>
Si vous n’avez pas d’accès direct à la machine, il peut être nécessaire de capturer à l’aide d’outils de ligne de commande tels que *tcpdump*. Si vous connaissez déjà le port TCP de la connexion, appliquez le filtre approprié afin d’éviter de capturer tout le trafic. Voici un exemple de ligne de commande tcpdump pour capturer le port 12345 sur <b>outfile.pcap</b>:


| `tcpdump -i any -w outfile.pcap tcp port 12345` |
| --- |


Le fichier <b>outfile.pcap</b> peut ensuite être ouvert à Wireshark pour une analyse plus approfondie.


<br><br>Manipulation du harnais<br><br><br><br> <br><br><br><br>
Cette rubrique suppose que vous connaissez les principes de base de Wireshark : capturer des paquets, définir des filtres simples, lire les détails des paquets. Une brève introduction est disponible sur [howTogether - Comment utiliser Wireshark pour capturer, filtrer et Inspect des paquets](https://www.howtogeek.com/104278/how-to-use-wireshark-to-capture-filter-and-inspect-packets/).

Pour filtrer le trafic SMPP dans Wireshark, il existe trois fonctionnalités importantes :

- Utilisez un filtre d&#39;affichage sur le port du SMS-C. Par exemple, si le SMS-C utilise le port 10000, utilisez le filtre suivant :
   *tcp.port == 10000*


Pour isoler des paquets par numéro de téléphone ou par contenu textuel, utilisez la fonction de recherche avec les paramètres suivants :
![smpp1](https://helpx.adobe.com/content/dam/help/en/campaign/kb/smpp-protocol-wireshark/jcr_content/main-pars/image/smpp1.png "smpp1")
- Utilisez la variable <b>Suivez le flux TCP</b> pour isoler le flux sur lequel vous travaillez.
Fermez la fenêtre de texte rouge/bleu qui s&#39;affiche, car elle n&#39;est utile que pour les protocoles de texte qui ne sont pas pertinents pour SMPP.
   ![smpp2](https://helpx.adobe.com/content/dam/help/en/campaign/kb/smpp-protocol-wireshark/jcr_content/main-pars/image_964579199/smpp2.png "smpp2")



<br><br><br><br>Protocole SMPP<br><br> <br><br>
Le protocole fonctionne sur TCP et est entièrement binaire, ce qui signifie que des outils spéciaux comme Wireshark (ou un éditeur hexadécimal) sont nécessaires pour déchiffrer le contenu du flux.

Le flux est constitué de PDU indépendants : chaque PDU est un message contenant une commande, un état, un numéro de séquence et d&#39;autres informations basées sur la commande.

En raison de la nature du protocole TCP en tant que protocole de diffusion, un paquet TCP peut contenir plusieurs PDU et les PDU peuvent couvrir plus de 2 paquets TCP ou plus. Wireshark réassemblera correctement les PDU, il est donc principalement transparent pour l&#39;utilisateur Wireshark.

Voici un exemple de PDU qui transite par le réseau lors de l&#39;envoi d&#39;un MT, puis de la réception d&#39;un SR :
![smpp3](https://helpx.adobe.com/content/dam/help/en/campaign/kb/smpp-protocol-wireshark/jcr_content/main-pars/image_388497282/smpp3.png "smpp3")
Remarque :

La liste des commandes standard se trouve dans la section 5.1.2.1 de la spécification SMPP (ensemble de commandes SMPP).
<br><br><br><br><br><br>Réponses SMPP<br><br><br><br> <br><br>
Le protocole SMPP requiert que toutes les commandes soient acquittées par un PDU de réponse :

BIND_TRANSMITTER est acquitté par *BIND_TRANSMITTER_RESP*, *SUBMIT_SM* est reconnu par *SUBMIT_SM_RESP*, etc.

Le délai d’attente des réponses est généralement de 10, 30 ou 60 secondes. La réponse peut contenir un accusé de réception positif (command_status = 0) ou une erreur (voir 5.1.3). *command_status*, *tableau 5-2* dans la spécification SMPP pour la liste des erreurs standard). La plupart du temps, ces réponses sont immédiates et un délai d’attente de réponse n’est pas atteint.

Veillez à faire la distinction entre les erreurs de réponse SMPP et les codes d&#39;erreur SR : le même code d&#39;erreur peut signifier différentes choses dans l&#39;erreur de réponse ou dans le champ d&#39;erreur SR. Lorsque vous signalez un code d’erreur, vous devez faire très attention à l’emplacement où vous l’avez trouvé, car la signification de la valeur dépend de son contexte.
<br><br><br><br><br><br>Initialisation de la connexion SMPP<br><br><br><br><br><br>
La connexion SMPP commence par une connexion via TCP. Ensuite, une opération BIND est envoyée par l’opération, acquittée par un RESP BIND. Ces opérations sont décrites dans la section 4.1 de la spécification SMPP (opération BIND).
![smpp4](https://helpx.adobe.com/content/dam/help/en/campaign/kb/smpp-protocol-wireshark/jcr_content/main-pars/image_468626174/smpp4.png "smpp4")
L’opération de liaison effectue la vérification de connexion/mot de passe et échange des informations sur le nom, la version et les autres champs de la plateforme décrits dans la spécification.

Remarque :

La connexion se trouve dans le champ system_id .



Dans Campaign, une *BIND_TRANSMITTER* paquet lors de l’initialisation d’un transfert MT et d’un *BIND_RECEIVER* packet quand *nlsm s* déclenche une connexion MO/SR.

<b>Émetteur, récepteur et émetteur : </b>Le connecteur SMPP pour Campaign Classic fonctionne en mode émetteur/récepteur distinct : il existe deux connexions TCP, l&#39;une pour transmettre MT et l&#39;autre pour recevoir MO et SR. Notez que la connexion TCP est toujours lancée par Campaign, même pour le mode récepteur.

SMPP fournit également un mode émetteur-récepteur, mais ce mode n&#39;est pas implémenté dans le connecteur SMPP pour Campaign Classic.

Le connecteur SMPP utilise plusieurs connexions en parallèle pour transmettre MT. Cela ne peut pas être contrôlé en raison de la conception du connecteur.
<br><br><br><br><br><br>Réception des MO<br><br><br><br><br><br>
Lorsque le récepteur est lié, le SMS-C peut envoyer un MO à tout moment. Le MO est envoyé à l’aide d’un *DELIVER_SM* PDU avec les bits 2 à 5 de *esm_clas s* clear (souvent, *esm_class* sera simplement 0).
![smpp5](https://helpx.adobe.com/content/dam/help/en/campaign/kb/smpp-protocol-wireshark/jcr_content/main-pars/image_695769115/smpp5.png "smpp5")
Le *DELIVER_SM* Le PDU doit recevoir une réponse rapide d&#39;un *DELIVER_SM_RESP* PDU avec le même *sequence_number*.
<br><br><br><br><br><br>Envoi MT<br><br><br><br><br><br>
Pour envoyer un MT, l&#39;émetteur doit être lié avec succès. Avant toute autre chose, vérifiez que le processus de liaison a bien été effectué.

Le MT est envoyé dans un *SUBMIT_SM* PDU. Le SMS-C doit rapidement répondre avec une *SUBMIT_SM_RESP* PDU : ce paquet de réponse est spécial, car il contient l’identifiant du message dans la base de données du SMS-C (incluez toujours cet identifiant lors de la conversation avec le partenaire SMS-C pour l’aider à trouver le message plus rapidement). Cet identifiant sera présent dans le SR et est le seul moyen de faire correspondre le MT avec son SR correspondant.

Le champ *registered_delivery* (décrit à la section 5.2.17 de la spécification) indique au SMSC si un SR est demandé pour ce MT spécifique. Si vous ne recevez pas de SR pour un message spécifique, vérifiez que le champ est correctement défini dans la variable *SUBMIT_SM* PDU.
![smpp5](https://helpx.adobe.com/content/dam/help/en/campaign/kb/smpp-protocol-wireshark/jcr_content/main-pars/image_1891077095/smpp5.png "smpp5")<br><br><br><br><br><br>Encodage des MT<br><br><br><br><br><br>
Attention :

L&#39;encodage des SMS est un sujet complexe avec de nombreux pièges et différentes mises en oeuvre.


<br><br><br><br> <br><br>
Il est recommandé de toujours contacter le partenaire SMS-C en cas de problème d&#39;encodage. Votre partenaire SMS possède une connaissance précise de l&#39;encodage pris en charge et des règles spéciales qui peuvent s&#39;appliquer en raison de limitations de sa plateforme technique. Faites-leur vérifier ce que vous leur envoyez et ce qu&#39;ils vous renvoient, c&#39;est le seul chemin vers une interconnexion stable et réussie.

Les messages SMS utilisent un encodage spécial de 7 bits, souvent appelé encodage GSM7. Reportez-vous à Wikipédia GSM 03.38 (en anglais).
<br><br><br><br> <br><br>
Dans le protocole SMPP, le texte GSM7 sera étendu à 8 bits par caractère pour faciliter le dépannage. Le SMS-C le compresse en 7 bits par caractère avant de l&#39;envoyer au mobile. Cela signifie que le champ short_message du SMS peut comporter jusqu&#39;à 160 octets dans le cadre SMPP, alors qu&#39;il est limité à 140 octets lorsqu&#39;il est envoyé sur le réseau mobile (le bit le plus significatif est simplement ignoré).

En cas de problème d&#39;encodage, voici quelques éléments importants à vérifier :

- Tout d’abord, assurez-vous de connaître les caractères à qui appartient l’encodage. GSM7 est tristement célèbre pour sa prise en charge partielle des signes diacritiques (accents). Surtout en français, où &quot;é&quot; et &quot;è&quot; font partie de GSM7, mais &quot;ê&quot;, &quot;â&quot; ou &quot;ï&quot; non. La situation n&#39;est pas meilleure en espagnol.
- Le C cédille (ç) n&#39;est présent que dans les majuscules de l&#39;alphabet GSM7, mais certains téléphones le rendent en minuscules ou &quot;smart&quot; : la recommandation générale est d&#39;éviter complètement la cédille (elle est encore très lisible en français) ou de passer à UCS-2.
- N’utilisez pas l’ASCII dans les SMS, sauf si le partenaire SMS-C le demande explicitement : cet encodage réduit l&#39;espace car il contient des caractères 8 bits et une couverture inférieure à celle de GSM7.
- Latin-1 n’est pas toujours pris en charge : vérifiez la compatibilité avec votre partenaire SMS-C avant de tenter d’utiliser Latin-1.
- Les tableaux de changement de langue nationale ne sont pas pris en charge par le connecteur Adobe Campaign Classic. Vous devez utiliser UCS-2 à la place.
- UCS-2 et UTF-16 sont souvent mélangés par les téléphones. C&#39;est un problème pour les personnes qui envoient des émoticônes et d&#39;autres caractères rarement utilisés qui ne sont pas présents dans UCS-2.
- L&#39;encodage GSM7 n&#39;est pas pris en charge par Wireshark : les caractères spéciaux s’affichent incorrectement. Si vous devez vérifier si une chaîne GSM7 est correctement encodée, vous devez comparer des codes hexadécimaux avec la table GSM7.


Le *data_coding* indique l’encodage utilisé. Le seul problème est que la valeur 0 signifie encodage par défaut du SMSC dans la spécification, mais en général, elle signifie GSM7. Vérifier avec le SMS-C *partenaire quel encodage est associé à data_coding = 0 (Adobe Campaign ne prend en charge que GSM7 pour data_coding* = 0).

La taille maximale d&#39;un message dépend de son encodage. Ce tableau récapitule toutes les informations pertinentes :
<br><br><br><br> <br>

| Encodage | data_coding | Taille du message (caractères)  | Taille de partie pour SMS à plusieurs parties  | Caractères disponibles  |
| --- | --- | --- | --- | --- |
| GSM 7 | 0 | 160 | 152 | [Jeu de caractères de base GSM7 + extension](https://en.wikipedia.org/wiki/GSM_03.38) (les caractères étendus prennent 2 caractères)  |
| Latin -1  | 3 | 140 | 134 | ISO-8859-1 |
| UCS-2 UTF-16  | 8 | 70 | 67 | Unicode (varie d&#39;un téléphone à l&#39;autre) |

<br><br><br><br><br>En-tête de données utilisateur (UDH)<br><br><br><br><br><br>
UDH (User Data Header) sont de petits en-têtes binaires ajoutés au texte d’un SMS. Ils peuvent déclencher des fonctionnalités spéciales telles que la concaténation SMS, les tableaux de changement de langue nationale, les logos/images (rarement utilisés) ou les notifications push WAP.

Comme l&#39;UDH fait partie du champ de texte (champ SMPP short_message), il raccourcit la taille effective d&#39;un SMS. Par exemple, un UDH SMS concaténé consomme 6 octets par partie SMS (c’est-à-dire 6 octets 8 bits réels et non des caractères 7 bits), laissant suffisamment de place pour seulement 152 caractères 7 bits par partie de message.

Wikipedia contient des articles intéressants sur l’en-tête de données utilisateur et les SMS concaténés (en anglais).

Pour savoir si un short_message contient un UDH, vérifiez les bits 6 et 7 de la classe esm (voir la section 5.2.12 de la spécification). Wireshark analyse l&#39;UDH dans l&#39;interface et fournit des informations précises.
![smpp7](https://helpx.adobe.com/content/dam/help/en/campaign/kb/smpp-protocol-wireshark/jcr_content/main-pars/image_738682084/smpp7.png "smpp7")
Dans la capture d&#39;écran ci-dessus, vous pouvez voir l&#39;en-tête de données de l&#39;utilisateur dans le champ de message (1), les informations contenues dans l&#39;UDH (2) et certaines informations supplémentaires qui n&#39;appartiennent pas au paquet mais qui sont calculées par Wireshark (3) : le champ Corps du message court est particulièrement intéressant, car il contient le message complet reconstitué par Wireshark.
<br><br><br><br><br><br>Réception d&#39;un SR<br><br><br><br><br><br>
Lorsque le récepteur est lié, le SMS-C peut envoyer du SR à tout moment. Le SR est envoyé à l&#39;aide d&#39;un PDU DELIVER_SM avec les bits 2-5 de *esm_class*définie.
![smpp8](https://helpx.adobe.com/content/dam/help/en/campaign/kb/smpp-protocol-wireshark/jcr_content/main-pars/image_158644074/smpp8.png "smpp8")
Le *DELIVER_SM* Le PDU doit recevoir une réponse rapide d&#39;un *DELIVER_SM_RESP* PDU avec le même *sequence_number*. Pour trouver le MT correspondant à ce SR, recherchez un *SUBMIT_SM_RESP* avec le même ID. Par exemple, il s&#39;agit du MT correspondant au SR :
![smpp9](https://helpx.adobe.com/content/dam/help/en/campaign/kb/smpp-protocol-wireshark/jcr_content/main-pars/image_1012110897/smpp9.png "smpp9")
Les SR ne sont envoyés que si la variable *registered_delivery* est défini dans le MT.

Remarque :

Le connecteur SMPP de Adobe Campaign Classic ne gère pas les SR qui arrivent avant *SUBMIT_SM_RESP* packet. La spécification n’interdit pas explicitement ce comportement, mais il est considéré comme un comportement incorrect (cela signifie que le message a été reçu avant d’être envoyé). Si vous rencontrez ce cas trop souvent, demandez à votre partenaire SMS-C de réparer sa plateforme.
<br><br><br><br><br><br>Décryptage du champ short_message du SR<br><br><br><br><br><br>
Le champ de texte des PDU SR a un encodage spécial décrit dans l&#39;Annexe B de la spécification du protocole SMPP. Malheureusement, ce format n&#39;est qu&#39;une recommandation sans faire partie du protocole, même si la plupart des SMS-C respectent plus ou moins ce format même.

Vous devez demander directement au partenaire SMS-C une documentation sur sa propre mise en oeuvre et vérifier qu&#39;il correspond à ce que vous voyez dans Wireshark. Le plus souvent, les implémentateurs de SMS-C ne connaissent même pas leur mise en oeuvre, ce qui entraîne des problèmes et des malentendus. N&#39;hésitez pas à demander de l&#39;aide au partenaire SMS-C en cas de doutes sur ce champ (notamment les codes d&#39;erreur).

Le format de base est le suivant :

*id:IIIIIIIII sub:SSS dlvrd:DDD date d’envoi:YYMMDDhmm done date:YYMMDDhmm stat:DDDDD err:EEE*

*Texte:........*

Voici des instructions générales pour lire la ligne ci-dessus :

- L’ID est le même que celui qui a été envoyé dans la variable *SUBMIT_SM_RESP* du MT correspondant.
- Vous pouvez ignorer les problèmes dans le champ de texte : ce champ est ignoré par Campaign car il est inutile, non fiable et peut même être complètement illisible si le SMS a été envoyé en utilisant un autre encodage que l&#39;ASCII alphanumérique pur. C&#39;est un comportement normal.
- Les noms de champ ne sont pas sensibles à la casse (par exemple, id : sub : Texte : peut également être noté en tant qu’ID : SOUS : text:).
- Le *dlvrd* n’est généralement pas fiable, sauf si le partenaire SMS-C le documente.
- Les dates peuvent avoir n&#39;importe quel fuseau horaire, ce qui les rend pratiquement inutiles, ou elles sont simplement fausses car l&#39;horloge du serveur distant est éteinte.
- Le *stat* peut avoir d’autres valeurs que celles définies dans l’Annexe B. Utilisez le bon sens et la documentation du partenaire SMSC pour comprendre sa signification.
- Le *err* dépend entièrement du SMS-C, et la plupart du temps, il est documenté par le partenaire SMS-C. Souvent, le code 000 signifie un succès, tandis que tout autre code indique des erreurs. Le champ est souvent numérique mais peut également être hexadécimal.

<br><br><br><br><br><br>Plusieurs SR pour le même MT<br><br><br><br><br><br>
Certains SMS-C envoient plusieurs SR pour le même MT pour suivre la progression du MT dans le réseau. Cette opération est principalement inutile, car la plupart du temps le client souhaite uniquement savoir quand le message a été reçu (il s’agit généralement du dernier SR).

En cas de doute, ne travaillez que sur le dernier SR reçu du SMS-C pour trouver l&#39;état d&#39;un message.
<br><br><br><br><br><br>Fenêtre SMPP<br><br><br><br><br><br>
Les opérations et les réponses étant asynchrones, vous pouvez optimiser les taux de transfert en envoyant plusieurs PDU d’opération avant d’attendre les réponses. Le nombre de messages sans réponse est appelé la fenêtre.

Exemple de transmission avec une fenêtre maximale de 4 :
![smpp10](https://helpx.adobe.com/content/dam/help/en/campaign/kb/smpp-protocol-wireshark/jcr_content/main-pars/image_2072040949/smpp10.png "smpp10")
L’implémentation actuelle ne contrôle pas la fenêtre et s’attend à ce que le SMS-C distant soit suffisamment rapide pour gérer les MT.
