---
title: Campaign Classic V7 - Optimisation de la requête SQL générée dans l’assistant de mise à jour de la base de données
description: Description
solution: Campaign,Campaign Classic v7
product: Campaign,Campaign Classic v7
applies-to: Campaign Classic,Campaign,Campaign Classic v7
keywords: KCS
resolution: Resolution
internal-notes: It can be helpful when dealing with database update issues with big tables
bug: true
article-created-by: Marta Zator
article-created-date: 5/5/2022 10:16:35 AM
article-published-by: Marta Zator
article-published-date: 5/5/2022 10:18:58 AM
version-number: 2
article-number: KA-15785
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=e810bb6a-5ccc-ec11-a7b5-6045bd00dbbc
exl-id: 73e8701c-88e5-4b73-8c55-90eaee26d2ac
source-git-commit: e8f4ca2dd578944d4fe399074fab461de88ad247
workflow-type: tm+mt
source-wordcount: '366'
ht-degree: 1%

---

# Campaign Classic V7 - Optimisation de la requête SQL générée dans l’assistant de mise à jour de la base de données

## Description


<b>Arrière-plan et contexte :</b>
Dans la plupart des builds Campaign, y compris les builds Gold Standard 9032, plusieurs problèmes peuvent se produire lors de l&#39;ajout de nouvelles colonnes à un schéma existant.

Le but de cet article est de résoudre un problème spécifique lié à :

- Ajouter un champ entier à un schéma existant lorsque des enregistrements existent déjà.
- Optimisez la requête SQL générée par l&#39;application à une requête Efficace pour Postgres SQL.


<b>Cas pratique :</b> 
<br>Nous avons une table de destinataires existante ou toute autre table qui a déjà plus d&#39;un million d&#39;enregistrements.
<br>Nous devons maintenant ajouter une colonne supplémentaire à cette table qui est un entier de type données.
<br>Nous ajoutons cette colonne dans la définition du schéma et nous voulons valider les modifications dans la base de données.

<b>Défi </b>:
<br>Nous rencontrons des problèmes lors de la mise à jour de la base de données et la base de données rencontre un blocage ou la requête bloque d’autres opérations.
<br>Cela est principalement dû à la mise à jour de tous les enregistrements vers 0 à partir de la commande SQL générée par l&#39;assistant de base de données.


<br> <br>

## Résolution


Solution :

Lors de l’ajout d’une colonne entière , l’instruction SQL générée est la suivante :

<b>ALTER TABLE NmsRecipient ADD column_name SMALLINT;
<br>METTRE À JOUR NmsRecipient SET column_name = 0;
<br>ALTER TABLE NmsRecipient ALTER COLONNE column_name SET Default 0;
<br>ALTER TABLE NmsRecipient ALTER COLONNE Iolumn_name SET NOT NULL;</b>

Le problème ici est qu&#39;il existe 4 commandes exécutées en parallèle dans la base de données, ce qui peut entraîner des problèmes de performances ou un blocage.

La solution consiste à condenser ces 4 commandes en une seule et même effectuer les mêmes modifications que ci-dessous :

<b>ALTER TABLE NmsRecipient AJOUT FichierLiveDataCliqueurs SMALLINT NOT NULL SET Default 0 ;</b>

Elle effectue toutes les modifications requises, en ajoutant la colonne, en définissant la valeur par défaut, en définissant NOT NULL et en définissant la valeur des enregistrements existants sur 0 en raison de la contrainte NOT NULL.



<b>REMARQUE :</b>

Si plusieurs colonnes entières doivent être ajoutées, ajoutez-les une par une et exécutez l’assistant de base de données pour chaque modification.

Cela permet d’assurer le bon fonctionnement puisque l’instruction met à jour toutes les <b>existant </b>enregistre également sur 0 et selon le nombre. des enregistrements qui peuvent prendre du temps.
